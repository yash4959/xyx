# üî¥ Interrupt Driven LED Blinking System Using 8086, 8253, 8255 and 8259

## üìå Introduction
In early microprocessor-based systems, tasks such as timing, I/O control, and event handling were implemented using dedicated peripheral chips. This project demonstrates a classical microprocessor system built around the Intel 8086 CPU and three essential support ICs: the 8253 Programmable Interval Timer, the 8255 Programmable Peripheral Interface, and the 8259 Programmable Interrupt Controller. The objective is to blink an LED using real hardware interrupts instead of software delay loops, thereby illustrating how real-time embedded systems are designed at the hardware‚Äìsoftware interface level.

This project serves as a complete educational example to understand how external peripherals interact with the CPU, how interrupts are generated and serviced, and how low-level assembly programs control hardware directly.

---

## üéØ Project Objectives
The objectives of this project are:
- To understand the interrupt mechanism of the 8086 microprocessor.
- To configure the 8253 timer to generate periodic timing pulses.
- To use the 8259 PIC to manage and forward interrupt requests.
- To interface the 8255 PPI to control an external LED.
- To design and execute an Interrupt Service Routine (ISR).
- To explore how the Interrupt Vector Table (IVT) redirects execution flow.
- To gain hands-on experience in real-mode assembly level programming.
- To study stack operation and context switching during interrupts.

---

## üß† Background Theory: Interrupt Driven Systems
In polling-based systems, the CPU continuously checks the status of peripherals to see if service is required. This wastes CPU time and is inefficient. In contrast, interrupt-driven systems allow peripherals to notify the CPU only when attention is required. The CPU can then suspend its current task, service the interrupt, and resume normal operation. This approach is widely used in real-time and embedded systems.

In this project, the timer periodically generates an interrupt to request the CPU to toggle the LED. The CPU does not waste time counting delays; instead, it relies entirely on hardware.

---

## ‚öôÔ∏è Components Used and Detailed Explanation

### üß† 8086 Microprocessor
The Intel 8086 is a 16-bit microprocessor with a 20-bit address bus capable of addressing 1 MB of memory. It supports segmented memory architecture and has dedicated support for interrupt handling.

Important features:
- 16-bit ALU and registers.
- 20-bit address bus (1 MB memory space).
- Real-mode operation.
- Supports 256 interrupt vectors.
- Dedicated pins: INTR (maskable interrupt) and NMI (non-maskable interrupt).
- Automatic stack operations during interrupt servicing.

Role in this project:
The 8086 executes the main program and services interrupts generated by the timer. When INTR is asserted by the 8259 PIC, the CPU saves its context and jumps to the ISR responsible for LED control.

---

### ‚è±Ô∏è 8253 Programmable Interval Timer
The Intel 8253 is a programmable timer/counter IC used to generate accurate time delays and periodic signals. It contains three independent 16-bit counters, each of which can be programmed in different modes.

Important features:
- Three 16-bit counters (Counter 0, 1, 2).
- Multiple modes including interrupt on terminal count, rate generator, square wave generator, etc.
- Accepts external clock input.
- Programmable via control word register.

Role in this project:
Counter 0 of the 8253 is programmed in Mode 2 (rate generator mode). In this mode, the counter continuously generates periodic low pulses after counting down from a preset value. These pulses are used to trigger interrupts, thereby defining the LED blinking rate.

Why Mode 2:
Mode 2 is ideal for periodic interrupt generation because it automatically reloads the count value and continues operation without further software intervention.

---

### üîå 8255 Programmable Peripheral Interface (PPI)
The Intel 8255 provides programmable parallel I/O ports to interface external devices with the CPU. It has three ports: Port A, Port B, and Port C (which can be split into upper and lower halves).

Important features:
- 24 I/O lines organized into three ports.
- Supports Mode 0 (simple I/O), Mode 1 (strobed), and Mode 2 (bi-directional).
- Ports can be individually configured as input or output.
- Controlled via a control word register.

Role in this project:
The 8255 is configured in Mode 0 with Port A as an output port. The LED is connected to one of the Port A pins. Writing a logic value to Port A directly controls the LED state. The ISR toggles this port bit to achieve blinking.

Why 8255:
It allows easy expansion of I/O capabilities of the 8086 and provides a clean way to interface LEDs, switches, displays, and other peripherals.

---

### üö¶ 8259 Programmable Interrupt Controller (PIC)
The Intel 8259 PIC is used to manage multiple interrupt sources and interface them to the CPU‚Äôs INTR pin. It handles prioritization, masking, and vector generation.

Important features:
- 8 interrupt request lines (IRQ0‚ÄìIRQ7).
- Programmable priority resolver.
- Interrupt masking capability.
- Provides interrupt vector numbers to the CPU.
- Supports cascading for more interrupts.

Role in this project:
The 8259 receives the interrupt pulse from the 8253 on IRQ0. It then sends an interrupt request to the 8086 via INTR. The PIC is programmed so that IRQ0 corresponds to vector 08h. Only IRQ0 is enabled, ensuring that only timer interrupts are serviced.

Why 8259:
The 8086 has only one INTR pin, so the PIC is necessary to handle multiple interrupt sources and manage them efficiently.

---

### üî¥ LED and Resistor
The LED acts as a visual output device. A current limiting resistor (typically 220Œ©) is connected in series to protect the LED from excessive current. The LED is driven by an output pin of Port A of the 8255.

Role in this project:
The LED provides a visible indication that the interrupt system is working correctly. Each interrupt toggles the LED state.

---

### üîã Power Supply and Clock
All ICs operate on a regulated +5V power supply. The 8253 requires a clock input, whose frequency determines the base timing resolution. Together with the programmed count value, this clock defines the interrupt interval.

---

## üîå System Interfacing and Connections
- The data bus of the 8086 is connected to all peripherals.
- Address lines are decoded to generate chip select signals for 8253, 8255, and 8259.
- 8253 Counter 0 output is connected to IRQ0 of 8259.
- 8259 INT output is connected to INTR of 8086.
- 8255 Port A is connected to the LED.
- Control and data registers of peripherals are mapped to specific I/O addresses.

This forms a complete microprocessor-based embedded system.

---

##  Circuit diagram:
![Circuit Diagram](Circuit/PROTEUS_CIRCUIT.jpeg)
---

## üö¶ Interrupt Mechanism in 8086

### üîπ What is an Interrupt?
An interrupt is a hardware or software signal that temporarily stops the CPU‚Äôs normal execution and transfers control to a special routine known as the Interrupt Service Routine.

### üîπ Types of Interrupts in 8086
- Hardware: INTR (maskable), NMI (non-maskable)
- Software: INT n instructions
- Internal: divide by zero, single step, etc.

This project uses a hardware maskable interrupt through INTR.

---

## üìö Interrupt Vector Table (IVT) in Detail
The IVT is a table of pointers located at physical memory address 00000h. It occupies the first 1024 bytes of memory. Each interrupt vector occupies 4 bytes: 2 bytes for offset (IP) and 2 bytes for segment (CS) of the ISR.

Address calculation:
Physical address of vector n = n √ó 4

For vector 08h:
08h √ó 4 = 20h

The program writes the ISR‚Äôs offset and segment into this location so that when the timer interrupt occurs, the CPU jumps to the correct ISR.

---

## üßæ Step-by-Step Interrupt Flow in This Project
1. The 8253 timer counts down based on the input clock.
2. When the count reaches zero, Counter 0 generates a pulse.
3. This pulse is applied to IRQ0 of the 8259 PIC.
4. The PIC checks if IRQ0 is unmasked and has highest priority.
5. The PIC asserts the INTR pin of the 8086.
6. The 8086 completes the current instruction.
7. The CPU pushes FLAGS, CS, and IP onto the stack.
8. The CPU fetches the ISR address from IVT entry for vector 08h.
9. Control jumps to the ISR.
10. The ISR toggles the LED via 8255.
11. The ISR sends End of Interrupt (EOI) command to the PIC.
12. The ISR executes IRET.
13. The CPU restores FLAGS, CS, IP and resumes main program.

This sequence repeats for every timer interrupt.

---

## üß† Interrupt Service Routine (ISR) Design
The ISR must be carefully designed to:
- Save any registers it uses.
- Perform the minimum required task quickly.
- Avoid long delays or loops.
- Send EOI to the PIC to clear the interrupt.
- Restore registers.
- Return using IRET.

In this project, the ISR simply toggles the LED state, making it short and efficient.

---

## üß† Stack Operation During Interrupts
When an interrupt occurs, the 8086 automatically uses the stack to save:
- FLAGS register
- Code Segment (CS)
- Instruction Pointer (IP)

This allows the CPU to return to the exact point after servicing the interrupt. Since this is a .COM program using a single segment, a stack area is reserved in the same segment and the Stack Pointer (SP) is initialized manually.

---

## ‚è±Ô∏è Timer-Based LED Blinking vs Delay Loops
Using delay loops wastes CPU time because the CPU remains busy counting. In contrast, timer-based interrupts allow the CPU to remain free for other tasks and respond only when required. This approach is more accurate, efficient, and scalable, and is used in real-time systems.

---

## ‚ñ∂Ô∏è Overall Program Flow
At startup, the program initializes segments and stack, installs the ISR address into the IVT, configures the 8255 for LED output, programs the 8253 timer, initializes the 8259 PIC, enables interrupts, and then enters an infinite loop. The CPU does nothing in the main loop, and all LED control is handled asynchronously by the ISR whenever the timer interrupt occurs.

---

## üì∏ Expected Output
Once the system is running, the LED connected to the 8255 Port A blinks periodically at a constant rate defined by the timer configuration, demonstrating successful interrupt-driven operation.

---

## üöÄ Learning Outcomes
After completing this project, one will understand:
- How real-mode interrupt handling works in 8086.
- How peripherals generate and route interrupts.
- How IVT maps interrupts to ISRs.
- How PIC prioritizes and masks requests.
- How timers are used for periodic tasks.
- How to design efficient ISRs.
- How low-level hardware interfacing is done.

---

## üìö Applications
The concepts used in this project form the basis of:
- Real-time operating systems
- Embedded controllers
- Industrial automation
- Timers and schedulers
- Event-driven systems
- Hardware abstraction layers

---


## üìú License
This project is open-source and intended purely for educational and academic use.

‚≠ê If you find this project useful, consider starring the repository!
